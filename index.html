<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arabia RAG Chat - Test Interface</title>
    <style>
      :root {
        --primary: #003366;
        --secondary: #80b2e0;
        --light: #f5f5f5;
        --dark: #333;
        --success: #28a745;
        --danger: #dc3545;
        --warning: #ffc107;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f3f3f3;
        line-height: 1.6;
        color: var(--dark);
      }

      .container {
        display: flex;
        min-height: 100vh;
      }

      .sidebar {
        width: 300px;
        background-color: var(--primary);
        color: white;
        padding: 20px;
        overflow-y: auto;
      }

      .main {
        flex: 1;
        display: flex;
        flex-direction: column;
        max-width: calc(100% - 300px);
      }

      .header {
        padding: 15px 20px;
        background-color: white;
        border-bottom: 1px solid #ddd;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.3s;
      }

      .btn-primary {
        background-color: var(--primary);
        color: white;
      }

      .btn-secondary {
        background-color: var(--secondary);
        color: white;
      }

      .btn-danger {
        background-color: var(--danger);
        color: white;
      }

      .btn-small {
        padding: 4px 8px;
        font-size: 0.8em;
      }

      .chat-area {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background-color: #fff;
      }

      .chat-input {
        padding: 15px 20px;
        background-color: white;
        border-top: 1px solid #ddd;
        display: flex;
      }

      .chat-input input {
        flex: 1;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-right: 10px;
      }

      .message {
        margin-bottom: 20px;
        max-width: 80%;
      }

      .message-user {
        margin-left: auto;
        background-color: var(--secondary);
        color: white;
        border-radius: 18px 18px 0 18px;
        padding: 12px 18px;
      }

      .message-ai {
        background-color: var(--light);
        border-radius: 18px 18px 18px 0;
        padding: 12px 18px;
        white-space: pre-wrap;
      }

      .sources {
        margin-top: 10px;
        font-size: 0.85em;
        color: #666;
        background-color: #f8f8f8;
        border-radius: 8px;
        padding: 8px 12px;
      }

      .sources a {
        color: var(--primary);
        text-decoration: none;
      }

      .sources a:hover {
        text-decoration: underline;
      }

      .auth-form {
        background-color: white;
        margin: 20px auto;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        max-width: 400px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .form-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .tabs {
        display: flex;
        margin-bottom: 20px;
      }

      .tab {
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }

      .tab.active {
        border-bottom-color: var(--primary);
        color: var(--primary);
        font-weight: 500;
      }

      .conversation-list {
        list-style: none;
        margin-top: 20px;
      }

      .conversation-item {
        padding: 10px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
      }

      .conversation-item:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }

      .conversation-item.active {
        background-color: rgba(255, 255, 255, 0.2);
        font-weight: 500;
      }

      .heading {
        font-size: 1.2em;
        margin-bottom: 10px;
        font-weight: 500;
      }

      .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .flex-center {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .typing-indicator {
        display: flex;
        align-items: center;
        margin: 10px 0;
      }

      .typing-indicator span {
        height: 8px;
        width: 8px;
        background: var(--secondary);
        border-radius: 50%;
        display: inline-block;
        margin: 0 2px;
        opacity: 0.4;
      }

      .typing-indicator span:nth-child(1) {
        animation: bounce 1s infinite 0.1s;
      }
      .typing-indicator span:nth-child(2) {
        animation: bounce 1s infinite 0.3s;
      }
      .typing-indicator span:nth-child(3) {
        animation: bounce 1s infinite 0.5s;
      }

      @keyframes bounce {
        50% {
          opacity: 1;
          transform: translateY(-5px);
        }
      }

      .hidden {
        display: none;
      }

      .badge {
        font-size: 0.7em;
        padding: 3px 8px;
        border-radius: 10px;
        color: white;
        background-color: var(--secondary);
      }

      .badge-anonymous {
        background-color: var(--warning);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Authentication sidebar -->
      <div id="auth-sidebar" class="sidebar">
        <h2>Arabia Chat</h2>
        <p>Islamic Research Assistant</p>

        <div id="login-status">
          <!-- Will be populated by JS -->
        </div>

        <div id="conversation-controls">
          <button
            id="new-conversation-btn"
            class="btn btn-secondary"
            style="margin-top: 20px; width: 100%"
          >
            New Conversation
          </button>
        </div>

        <div class="heading" style="margin-top: 20px">My Conversations</div>
        <ul id="conversation-list" class="conversation-list">
          <!-- Will be populated by JS -->
        </ul>
      </div>

      <!-- Main content area -->
      <div class="main">
        <!-- Auth forms will be shown when not logged in -->
        <div id="auth-container" class="auth-form">
          <div class="tabs">
            <div class="tab active" data-tab="login">Login</div>
            <div class="tab" data-tab="register">Register</div>
            <div class="tab" data-tab="anonymous">Anonymous</div>
          </div>

          <!-- Login Form -->
          <div id="login-tab" class="tab-content">
            <div class="form-group">
              <label for="login-email">Email</label>
              <input
                type="email"
                id="login-email"
                placeholder="Enter your email"
              />
            </div>
            <div class="form-group">
              <label for="login-password">Password</label>
              <input
                type="password"
                id="login-password"
                placeholder="Enter your password"
              />
            </div>
            <button id="login-btn" class="btn btn-primary" style="width: 100%">
              Login
            </button>
          </div>

          <!-- Register Form -->
          <div id="register-tab" class="tab-content hidden">
            <div class="form-group">
              <label for="register-name">Name</label>
              <input
                type="text"
                id="register-name"
                placeholder="Enter your name"
              />
            </div>
            <div class="form-group">
              <label for="register-email">Email</label>
              <input
                type="email"
                id="register-email"
                placeholder="Enter your email"
              />
            </div>
            <div class="form-group">
              <label for="register-password">Password</label>
              <input
                type="password"
                id="register-password"
                placeholder="Enter a strong password"
              />
            </div>
            <button
              id="register-btn"
              class="btn btn-primary"
              style="width: 100%"
            >
              Register
            </button>
          </div>

          <!-- Anonymous Access -->
          <div id="anonymous-tab" class="tab-content hidden">
            <p style="margin-bottom: 20px">
              Continue without an account to test the chat functionality.
            </p>
            <button
              id="anonymous-btn"
              class="btn btn-secondary"
              style="width: 100%"
            >
              Continue Anonymously
            </button>
          </div>
        </div>

        <!-- Chat interface will be shown when logged in -->
        <div id="chat-container" class="hidden" style="height: 100%">
          <div class="header">
            <div>
              <span id="conversation-title">New Conversation</span>
              <span id="user-badge" class="badge hidden">User</span>
              <span id="anonymous-badge" class="badge badge-anonymous hidden"
                >Anonymous</span
              >
            </div>
            <div>
              <button
                id="use-streaming-btn"
                class="btn btn-small btn-secondary"
              >
                Toggle Streaming
              </button>
              <button id="logout-btn" class="btn btn-small btn-danger">
                Logout
              </button>
            </div>
          </div>

          <div id="chat-area" class="chat-area">
            <!-- Messages will be added here -->
          </div>

          <div class="chat-input">
            <input
              type="text"
              id="message-input"
              placeholder="Type your message..."
            />
            <button id="send-btn" class="btn btn-primary">Send</button>
          </div>
        </div>
      </div>
    </div>

    <div
      id="debug-panel"
      style="
        position: fixed;
        bottom: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        font-size: 12px;
        max-width: 300px;
        max-height: 200px;
        overflow: auto;
        z-index: 9999;
      "
    >
      <div id="debug-log"></div>
    </div>

    <script>
      // API base URL - change to your deployed server URL
      const API_BASE_URL = "http://localhost:8000";

      // State management
      const state = {
        token: localStorage.getItem("token"),
        isAnonymous: localStorage.getItem("isAnonymous") === "true",
        userId: localStorage.getItem("userId"),
        conversations: [],
        currentConversationId: null,
        messages: [],
        useStreaming: localStorage.getItem("useStreaming") === "true" || false,
      };

      // DOM Elements
      const elements = {
        authContainer: document.getElementById("auth-container"),
        chatContainer: document.getElementById("chat-container"),
        loginTab: document.getElementById("login-tab"),
        registerTab: document.getElementById("register-tab"),
        anonymousTab: document.getElementById("anonymous-tab"),
        tabs: document.querySelectorAll(".tab"),
        loginBtn: document.getElementById("login-btn"),
        registerBtn: document.getElementById("register-btn"),
        anonymousBtn: document.getElementById("anonymous-btn"),
        logoutBtn: document.getElementById("logout-btn"),
        loginEmail: document.getElementById("login-email"),
        loginPassword: document.getElementById("login-password"),
        registerName: document.getElementById("register-name"),
        registerEmail: document.getElementById("register-email"),
        registerPassword: document.getElementById("register-password"),
        messageInput: document.getElementById("message-input"),
        sendBtn: document.getElementById("send-btn"),
        chatArea: document.getElementById("chat-area"),
        loginStatus: document.getElementById("login-status"),
        conversationList: document.getElementById("conversation-list"),
        newConversationBtn: document.getElementById("new-conversation-btn"),
        conversationTitle: document.getElementById("conversation-title"),
        userBadge: document.getElementById("user-badge"),
        anonymousBadge: document.getElementById("anonymous-badge"),
        useStreamingBtn: document.getElementById("use-streaming-btn"),
      };

      // Place this at the top level before any functions
      const pendingRequests = {};
      const completedRequests = {};

      // Flag to ensure init only runs once
      let initialized = false;

      // Initialize the app
      function init() {
        if (initialized) {
          console.log("Already initialized, skipping");
          return;
        }

        initialized = true;
        console.log("Initializing app...");

        setupEventListeners();
        checkAuthState();
        updateStreamingButton();
      }

      // Set up event listeners
      function setupEventListeners() {
        // Tab switching
        elements.tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            elements.tabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");

            // Hide all tab content
            document.querySelectorAll(".tab-content").forEach((content) => {
              content.classList.add("hidden");
            });

            // Show selected tab content
            const tabId = tab.getAttribute("data-tab");
            document.getElementById(`${tabId}-tab`).classList.remove("hidden");
          });
        });

        // Auth buttons
        elements.loginBtn.addEventListener("click", login);
        elements.registerBtn.addEventListener("click", register);
        elements.anonymousBtn.addEventListener("click", anonymousLogin);
        elements.logoutBtn.addEventListener("click", logout);

        // Chat functionality
        elements.sendBtn.addEventListener("click", sendMessage);
        elements.messageInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") sendMessage();
        });

        // Conversation management
        elements.newConversationBtn.addEventListener(
          "click",
          createNewConversation
        );

        // Streaming toggle
        elements.useStreamingBtn.addEventListener("click", toggleStreaming);
      }

      // Check authentication state
      function checkAuthState() {
        if (state.token) {
          showChatInterface();
          loadConversations();
          updateUserStatus();
        } else {
          showAuthInterface();
        }
      }

      // Toggle between streaming and non-streaming
      function toggleStreaming() {
        state.useStreaming = !state.useStreaming;
        localStorage.setItem("useStreaming", state.useStreaming);
        updateStreamingButton();
      }

      function updateStreamingButton() {
        if (state.useStreaming) {
          elements.useStreamingBtn.textContent = "Disable Streaming";
          elements.useStreamingBtn.classList.add("btn-primary");
          elements.useStreamingBtn.classList.remove("btn-secondary");
        } else {
          elements.useStreamingBtn.textContent = "Enable Streaming";
          elements.useStreamingBtn.classList.remove("btn-primary");
          elements.useStreamingBtn.classList.add("btn-secondary");
        }
      }

      // Show the authentication interface
      function showAuthInterface() {
        elements.authContainer.classList.remove("hidden");
        elements.chatContainer.classList.add("hidden");
      }

      // Show the chat interface
      function showChatInterface() {
        elements.authContainer.classList.add("hidden");
        elements.chatContainer.classList.remove("hidden");
      }

      // Update the user status display
      function updateUserStatus() {
        if (state.isAnonymous) {
          elements.loginStatus.innerHTML = `
                    <div style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div><strong>Anonymous User</strong></div>
                        <div style="font-size: 0.8em; opacity: 0.8;">Your chats will not be saved</div>
                    </div>
                `;
          elements.anonymousBadge.classList.remove("hidden");
          elements.userBadge.classList.add("hidden");
        } else {
          elements.loginStatus.innerHTML = `
                    <div style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div><strong>Logged In</strong></div>
                        <div style="font-size: 0.8em; opacity: 0.8;">User ID: ${
                          state.userId || "Unknown"
                        }</div>
                    </div>
                `;
          elements.userBadge.classList.remove("hidden");
          elements.anonymousBadge.classList.add("hidden");
        }
      }

      // API Calls
      async function apiCall(endpoint, method = "GET", data = null) {
        // Create a request signature
        const requestSignature = `${method}:${endpoint}:${JSON.stringify(
          data
        )}`;
        const now = Date.now();

        // Prevent duplicate requests within 500ms
        if (
          completedRequests[requestSignature] &&
          now - completedRequests[requestSignature] < 500
        ) {
          console.log("Preventing duplicate request:", requestSignature);
          return pendingRequests[requestSignature];
        }

        // Check if this exact request is already in progress
        if (pendingRequests[requestSignature]) {
          console.log("Request already in progress:", requestSignature);
          return pendingRequests[requestSignature];
        }

        const headers = {
          "Content-Type": "application/json",
        };

        if (state.token) {
          headers["Authorization"] = `Bearer ${state.token}`;
        }

        try {
          // Create a new promise for this request
          const requestPromise = new Promise(async (resolve) => {
            try {
              console.log("Making API request:", method, endpoint);
              const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                method,
                headers,
                body: data ? JSON.stringify(data) : null,
              });

              if (response.status === 401) {
                logout();
                resolve({
                  error: "Authentication expired. Please log in again.",
                });
                return;
              }

              const contentType = response.headers.get("content-type");
              let result;
              if (contentType && contentType.includes("application/json")) {
                result = await response.json();
              } else {
                result = await response.text();
              }

              // Save this as a completed request
              completedRequests[requestSignature] = Date.now();
              resolve(result);
            } catch (error) {
              console.error("API Error:", error);
              resolve({ error: error.message });
            }
          });

          // Store the promise
          pendingRequests[requestSignature] = requestPromise;

          // Wait for completion and clean up
          const result = await requestPromise;
          delete pendingRequests[requestSignature];
          return result;
        } catch (error) {
          console.error("API Error:", error);
          return { error: error.message };
        }
      }

      // Authentication functions
      async function login() {
        const email = elements.loginEmail.value;
        const password = elements.loginPassword.value;

        if (!email || !password) {
          alert("Please enter both email and password");
          return;
        }

        elements.loginBtn.innerHTML = '<div class="spinner"></div>';
        elements.loginBtn.disabled = true;

        const response = await apiCall("/auth/login", "POST", {
          email,
          password,
        });

        elements.loginBtn.innerHTML = "Login";
        elements.loginBtn.disabled = false;

        if (response.error) {
          alert(`Login failed: ${response.error}`);
          return;
        }

        if (response.access_token) {
          state.token = response.access_token;
          state.isAnonymous = false;

          // Extract user ID from JWT if possible
          try {
            const payload = JSON.parse(
              atob(response.access_token.split(".")[1])
            );
            state.userId = payload.sub || "user";
          } catch (e) {
            state.userId = "user";
          }

          localStorage.setItem("token", state.token);
          localStorage.setItem("isAnonymous", "false");
          localStorage.setItem("userId", state.userId);

          showChatInterface();
          loadConversations();
          updateUserStatus();
        } else {
          alert("Login failed: Invalid response from server");
        }
      }

      async function register() {
        const name = elements.registerName.value;
        const email = elements.registerEmail.value;
        const password = elements.registerPassword.value;

        if (!name || !email || !password) {
          alert("Please fill out all fields");
          return;
        }

        elements.registerBtn.innerHTML = '<div class="spinner"></div>';
        elements.registerBtn.disabled = true;

        const response = await apiCall("/auth/register", "POST", {
          name,
          email,
          password,
        });

        elements.registerBtn.innerHTML = "Register";
        elements.registerBtn.disabled = false;

        if (response.error) {
          alert(`Registration failed: ${response.error}`);
          return;
        }

        // Success - now login
        elements.loginEmail.value = email;
        elements.loginPassword.value = password;

        // Switch to login tab
        elements.tabs[0].click();

        alert("Registration successful! You can now log in.");
      }

      async function anonymousLogin() {
        elements.anonymousBtn.innerHTML = '<div class="spinner"></div>';
        elements.anonymousBtn.disabled = true;

        // Your backend might have an anonymous token endpoint, or we can just proceed without a token
        try {
          const response = await apiCall("/auth/anonymous", "POST");

          if (response.access_token) {
            state.token = response.access_token;
          } else {
            // If no anonymous endpoint, just create a dummy token
            state.token =
              "anonymous_" + Math.random().toString(36).substring(2);
          }

          state.isAnonymous = true;
          state.userId = "anonymous_user";

          localStorage.setItem("token", state.token);
          localStorage.setItem("isAnonymous", "true");
          localStorage.setItem("userId", state.userId);

          showChatInterface();
          createNewConversation();
          updateUserStatus();
        } catch (error) {
          console.error("Anonymous login error:", error);

          // Fallback to client-side anonymous token
          state.token = "anonymous_" + Math.random().toString(36).substring(2);
          state.isAnonymous = true;
          state.userId = "anonymous_user";

          localStorage.setItem("token", state.token);
          localStorage.setItem("isAnonymous", "true");
          localStorage.setItem("userId", state.userId);

          showChatInterface();
          createNewConversation();
          updateUserStatus();
        }

        elements.anonymousBtn.innerHTML = "Continue Anonymously";
        elements.anonymousBtn.disabled = false;
      }

      function logout() {
        state.token = null;
        state.isAnonymous = false;
        state.userId = null;
        state.conversations = [];
        state.currentConversationId = null;
        state.messages = [];

        localStorage.removeItem("token");
        localStorage.removeItem("isAnonymous");
        localStorage.removeItem("userId");

        showAuthInterface();
      }

      // Use a flag to prevent multiple simultaneous sendMessage calls
      let messageSendInProgress = false;

      async function sendMessage() {
        // Prevent multiple sends at once
        if (messageSendInProgress) {
          console.log("Message send already in progress, ignoring");
          return;
        }

        const messageText = elements.messageInput.value.trim();
        if (!messageText) return;

        try {
          messageSendInProgress = true;

          // Clear input
          elements.messageInput.value = "";

          // Add user message to UI
          addMessageToUI("user", messageText);

          // Create a typing indicator
          const indicatorId = "typing-" + Date.now();
          addTypingIndicator(indicatorId);

          // Make sure we have a conversation ID
          if (!state.currentConversationId) {
            await createNewConversation();
          }

          console.log(
            "Sending message to conversation:",
            state.currentConversationId
          );

          if (state.useStreaming) {
            // Remove the typing indicator
            removeTypingIndicator(indicatorId);
            // Use streaming endpoint
            await streamResponse(messageText);
          } else {
            // Send to API
            const response = await apiCall("/chat/messages", "POST", {
              content: messageText,
              conversation_id: state.currentConversationId,
            });

            // Remove the typing indicator
            removeTypingIndicator(indicatorId);

            console.log("Received response:", response);

            // Add AI response to UI
            if (response.ai_message) {
              addMessageToUI(
                "ai",
                response.ai_message.content,
                response.ai_message.sources
              );
            } else if (response.error) {
              addMessageToUI("ai", `Error: ${response.error}`);
            } else {
              addMessageToUI("ai", "Sorry, I could not generate a response.");
            }
          }
        } catch (error) {
          console.error("Send message error:", error);
          removeTypingIndicator(indicatorId);
          addMessageToUI("ai", `Error: ${error.message}`);
        } finally {
          messageSendInProgress = false;
        }
      }

      // Stream the response
      async function streamResponse(messageText) {
        try {
          const response = await fetch(`${API_BASE_URL}/chat/messages/stream`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...(state.token
                ? { Authorization: `Bearer ${state.token}` }
                : {}),
            },
            body: JSON.stringify({
              content: messageText,
              conversation_id: state.currentConversationId,
            }),
          });

          // Create a message element for the streaming response
          const messageEl = document.createElement("div");
          messageEl.className = "message message-ai";
          messageEl.textContent = "";

          const sourcesEl = document.createElement("div");
          sourcesEl.className = "sources hidden";

          const wrapperEl = document.createElement("div");
          wrapperEl.appendChild(messageEl);
          wrapperEl.appendChild(sourcesEl);

          elements.chatArea.appendChild(wrapperEl);
          elements.chatArea.scrollTop = elements.chatArea.scrollHeight;

          let sourceStarted = false;

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split("\n\n");

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const content = line.substring(6);

                if (content === "[DONE]") {
                  continue;
                } else if (content.startsWith("Sources:")) {
                  sourceStarted = true;
                  sourcesEl.classList.remove("hidden");
                  sourcesEl.innerHTML = "<strong>Sources:</strong>";
                } else if (sourceStarted && content.startsWith("[")) {
                  const sourceLink = document.createElement("div");
                  sourceLink.innerHTML = content;
                  sourcesEl.appendChild(sourceLink);
                } else {
                  messageEl.textContent += content;
                }

                elements.chatArea.scrollTop = elements.chatArea.scrollHeight;
              }
            }
          }
        } catch (error) {
          console.error("Streaming error:", error);
          addMessageToUI("ai", `Error streaming response: ${error.message}`);
        }
      }

      function addMessageToUI(role, content, sources = null) {
        const messageEl = document.createElement("div");
        messageEl.className = `message message-${role}`;
        messageEl.textContent = content;

        const wrapperEl = document.createElement("div");
        wrapperEl.appendChild(messageEl);

        if (sources && sources.length > 0) {
          const sourcesEl = document.createElement("div");
          sourcesEl.className = "sources";

          let sourcesHTML = "<strong>Sources:</strong>";

          sources.forEach((source, index) => {
            const url =
              source.url ||
              `https://shamela.ws/book/${extractBookId(source.document_id)}`;
            sourcesHTML += `
                        <div>
                            ${index + 1}. ${source.book_name} - ${
              source.section_title
            }
                            <a href="${url}" target="_blank">[View]</a>
                        </div>
                    `;
          });

          sourcesEl.innerHTML = sourcesHTML;
          wrapperEl.appendChild(sourcesEl);
        }

        elements.chatArea.appendChild(wrapperEl);
        elements.chatArea.scrollTop = elements.chatArea.scrollHeight;
      }

      function extractBookId(documentId) {
        if (!documentId) return "";

        const parts = documentId.split("_");
        if (parts && parts[0] && !isNaN(parts[0])) {
          return parts[0];
        }
        return "";
      }

      function addTypingIndicator(id) {
        const indicator = document.createElement("div");
        indicator.id = id;
        indicator.className = "typing-indicator";
        indicator.innerHTML = "<span></span><span></span><span></span>";

        elements.chatArea.appendChild(indicator);
        elements.chatArea.scrollTop = elements.chatArea.scrollHeight;
      }

      function removeTypingIndicator(id) {
        const indicator = document.getElementById(id);
        if (indicator) {
          indicator.remove();
        }
      }

      // Conversation functions
      async function loadConversations() {
        if (state.isAnonymous) {
          // For anonymous users, we just create a new conversation
          createNewConversation();
          return;
        }

        try {
          const response = await apiCall("/chat/conversations");

          if (Array.isArray(response)) {
            state.conversations = response;
            renderConversationList();

            if (response.length > 0) {
              selectConversation(response[0].conversation_id);
            } else {
              createNewConversation();
            }
          } else {
            console.error("Invalid conversations response:", response);
            createNewConversation();
          }
        } catch (error) {
          console.error("Load conversations error:", error);
          createNewConversation();
        }
      }

      function renderConversationList() {
        elements.conversationList.innerHTML = "";

        state.conversations.forEach((conversation) => {
          const li = document.createElement("li");
          li.className = "conversation-item";
          if (conversation.conversation_id === state.currentConversationId) {
            li.classList.add("active");
          }

          const title = conversation.title || "New Conversation";
          const date = new Date(conversation.created_at).toLocaleDateString();

          li.innerHTML = `
                    <span>${title}</span>
                    <span style="font-size: 0.8em; opacity: 0.7;">${date}</span>
                `;

          li.addEventListener("click", () => {
            selectConversation(conversation.conversation_id);
          });

          elements.conversationList.appendChild(li);
        });
      }

      async function selectConversation(conversationId) {
        state.currentConversationId = conversationId;
        elements.conversationTitle.textContent = "Loading conversation...";
        elements.chatArea.innerHTML = "";

        try {
          // Find conversation in state
          const conversation = state.conversations.find(
            (c) => c.conversation_id === conversationId
          );
          if (conversation) {
            elements.conversationTitle.textContent =
              conversation.title || "Conversation";
          }

          // Load messages
          const response = await apiCall(
            `/chat/conversations/${conversationId}/messages`
          );

          if (Array.isArray(response)) {
            // Clear chat area
            elements.chatArea.innerHTML = "";

            // Sort messages by timestamp
            const sortedMessages = response.sort((a, b) => {
              return new Date(a.timestamp) - new Date(b.timestamp);
            });

            // Add messages to UI
            sortedMessages.forEach((message) => {
              addMessageToUI(
                message.message_type,
                message.content,
                message.sources
              );
            });
          }

          // Update conversation list UI
          renderConversationList();
        } catch (error) {
          console.error("Select conversation error:", error);
          elements.conversationTitle.textContent = "Error loading conversation";
        }
      }

      async function createNewConversation() {
        try {
          const response = await apiCall("/chat/conversations", "POST");

          if (response.conversation_id) {
            state.currentConversationId = response.conversation_id;
            elements.conversationTitle.textContent = "New Conversation";
            elements.chatArea.innerHTML = "";

            if (!state.isAnonymous) {
              // Reload conversations to get the new one
              loadConversations();
            }
          } else {
            console.error("Create conversation failed:", response);
            state.currentConversationId = "temp_" + Date.now();
            elements.conversationTitle.textContent = "Temporary Conversation";
          }
        } catch (error) {
          console.error("Create conversation error:", error);
          state.currentConversationId = "temp_" + Date.now();
          elements.conversationTitle.textContent = "Temporary Conversation";
        }
      }

      // Debug helper
      function debugLog(message) {
        const debugLogEl = document.getElementById("debug-log");
        if (debugLogEl) {
          const timestamp = new Date().toLocaleTimeString();
          debugLogEl.innerHTML += `<div>[${timestamp}] ${message}</div>`;
          debugLogEl.scrollTop = debugLogEl.scrollHeight;

          // Limit to last 20 messages
          const messages = debugLogEl.querySelectorAll("div");
          if (messages.length > 20) {
            messages[0].remove();
          }
        }
        console.log(message);
      }

      // Replace console.log
      const originalConsoleLog = console.log;
      console.log = function (...args) {
        originalConsoleLog.apply(console, args);
        debugLog(args.join(" "));
      };

      // Start the app
      init();
    </script>
  </body>
</html>
